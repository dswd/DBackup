#!/bin/bash

ARCHIVE="/var/lib/dbackup"

NAME="$1"
shift

usage() {
  cat <<EOF
Usage: $0 name cmd [opts]
   name: The name of the duplicity backup entry

The following commands exist:

$0 NAME create
	Creates a new backup entry
$0 NAME edit [config|excludes]
	Edit the exclude list or the config (default) of the backup entry
$0 NAME status
	Show the status of a backup entry
$0 NAME files
	Show the list of all files in the backup of a backup entry
$0 NAME logs
	Show the log file of a backup entry
$0 NAME backup
	Run a normal backup, duplicity decides whether this is incremental or full
$0 NAME full
	Run a full backup
$0 NAME verify
	Verify the backups
$0 NAME restore DST [--file-to-restore PATH] [--time AGE]
	Restore a backup. To avoid overwriting files, files are restored to the given destination.
	Subsets of the backup can be restored by giving the PATH of the files (without leading /)
	If AGE is given, the backup of that date is used instead of the most recent
$0 NAME clean
	Clean up leftovers from aborted runs
$0 NAME remove AGE [--force]
	Remove backup sets older than AGE
	--force must be used to actually delete the files instead of just listing them
EOF
}

if [ -z "$NAME" ]; then
  usage
  exit 0
fi

#Can be overwritten by config file
EXEC_BEFORE="$ARCHIVE/$NAME/exec_before.sh"
EXEC_AFTER="$ARCHIVE/$NAME/exec_after.sh"
LOGFILE="/var/log/dbackup/$NAME"
DUPLICITY="/usr/bin/duplicity"

CONFFILE="$ARCHIVE/$NAME/conf"
if [ -f "$CONFFILE" ]; then
  . "$CONFFILE"
else
  if [ "$1" == "create" ]; then
    cp -a "$ARCHIVE/.example" "$ARCHIVE/$NAME"
    exit 0
  else
    echo "No such profile: $NAME" 1>&2
    exit -1
  fi
fi


OPTS=( "${OPTS[@]}" --archive "$ARCHIVE" --name "$NAME" )

BAREOPTS=( "${OPTS[@]}" )

EXCLUDEFILE="$ARCHIVE/$NAME/exclude"
if [ -f "$EXCLUDEFILE" ]; then
  OPTS=( "${OPTS[@]}" --exclude-globbing-filelist "$EXCLUDEFILE" )
fi

ARG="$1"
shift

function run() {
	MODE=$1
	if [ -x "$EXEC_BEFORE" ]; then
		$EXEC_BEFORE || exit -4
	fi
	$DUPLICITY "${OPTS[@]}" "$@" $MODE $LOCAL $REMOTE | tee -a $LOGFILE
	if [ -x "$EXEC_AFTER" ]; then
		$EXEC_AFTER || exit -4
	fi
}

case "$ARG" in
	create )
		echo "$NAME already exists" >&2
		exit -3
		;;
	edit )
		case "$1" in
			exclude | excludes )
				${EDITOR:-nano} "$EXCLUDEFILE"
				;;
			config | * )
				${EDITOR:-nano} "$CONFFILE"
				;;
		esac
		;;
	status )
		$DUPLICITY "${OPTS[@]}" "$@" collection-status $REMOTE
		;;
	files | list )
		$DUPLICITY "${OPTS[@]}" "$@" list-current-files $REMOTE
		;;
	run | backup )
		run 
		;;
	full )
		run full
		;;
	verify )
		$DUPLICITY "${OPTS[@]}" "$@" verify $REMOTE $LOCAL
		;;
	restore )
		DST="$1"
		shift
		$DUPLICITY "${BAREOPTS[@]}" "$@" restore $REMOTE "$DST"
		;;
	clean )
		$DUPLICITY "${OPTS[@]}" "$@" clean $REMOTE
		;;
	logs )
		less $LOGFILE
		;;
	remove )
		TIME="$1"
		shift
		$DUPLICITY  "${OPTS[@]}" remove-older-than $TIME "$@" $REMOTE
		;;
        schedule )
		CHANGE="$1"
		CURRENT="none"
		for period in hourly daily weekly monthly yearly; do
			if [ -f "/etc/cron.$period/dbackup-$NAME" ]; then
				CURRENT="$period"
			fi
		done
		if [ "$CHANGE" == "" ]; then
			echo "Schedule of $NAME backup: $CURRENT"
		else
			rm -f "/etc/cron.$CURRENT/dbackup-$NAME"
			cat <<EOF > "/etc/cron.$CHANGE/dbackup-$NAME"
#!/bin/bash
$(which dbackup) $NAME run >/dev/null
EOF
		fi
                ;;
	* )
		usage
		exit -2
		;;
esac
